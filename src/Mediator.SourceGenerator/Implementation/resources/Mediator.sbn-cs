// <auto-generated>
//     Generated by the Mediator source generator.
// </auto-generated>

#pragma warning disable CS8019 // Unused usings
#pragma warning disable CS8321 // Unused local function
#pragma warning disable CS1998 // Async method lacks 'await' operators and will run synchronously

#nullable enable

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using System.Linq;

using SD = global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor;

namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    /// DI extensions for Mediator.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    public static class MediatorDependencyInjectionExtensions
    {
        /// <summary>
        /// Adds the Mediator implementation and handlers of your application.
        /// </summary>
        public static IServiceCollection AddMediator(this IServiceCollection services)
        {
            return AddMediator(services, null);
        }

        /// <summary>
        /// Adds the Mediator implementation and handlers of your application, with specified options.
        /// </summary>
        public static IServiceCollection AddMediator(this IServiceCollection services, global::System.Action<global::Mediator.MediatorOptions>? options)
        {
            var opts = new global::Mediator.MediatorOptions();
            if (options != null)
                options(opts);

            var configuredViaAttribute = {{ ConfiguredViaAttribute }};
            if (opts.ServiceLifetime != {{ ServiceLifetime }} && !configuredViaAttribute)
            {
                var errMsg = "Invalid configuration detected for Mediator. ";
                errMsg += "Generated code for '{{ ServiceLifetimeShort }}' lifetime, but got '" + opts.ServiceLifetime + "' lifetime from options. ";
                errMsg += "This means that the source generator hasn't seen the 'AddMediator' method call during compilation. ";
                errMsg += "Make sure that the 'AddMediator' method is called from the project that references the Mediator.SourceGenerator package.";
                throw new global::System.Exception(errMsg);
            }

            {{~ if ServiceLifetimeIsScoped || ServiceLifetimeIsTransient ~}}
            services.Add(new SD(typeof(global::{{ MediatorNamespace }}.Mediator), typeof(global::{{ MediatorNamespace }}.Mediator), {{ ServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.IMediator), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ ServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.ISender), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ ServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.IPublisher), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ ServiceLifetime }}));
            {{ else }}
            services.Add(new SD(typeof(global::{{ MediatorNamespace }}.Mediator), typeof(global::{{ MediatorNamespace }}.Mediator), {{ SingletonServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.IMediator), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ SingletonServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.ISender), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ SingletonServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.IPublisher), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ SingletonServiceLifetime }}));
            {{~ end ~}}

            {{~ for message in RequestMessages ~}}
            {{ message.Handler.ServiceRegistrationBlock }}
            services.Add(new SD(
                typeof({{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}),
                sp =>
                {
                    return new {{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}(
                        sp.GetRequiredService<{{ message.Handler.FullName }}>(),
                        sp.GetServices<{{ message.PipelineHandlerType }}>()
                    );
                },
                {{ message.Handler.ServiceLifetime }}
            ));
            {{~ end ~}}

            {{~ for handler in NotificationMessageHandlers ~}}
            {{ handler.ServiceRegistrationBlock }}
            {{~ end ~}}

            {{~ for message in NotificationMessages ~}}
            {{~ for registration in message.HandlerServicesRegistrationBlock ~}}
            {{ registration }}
            {{~ end ~}}
            {{~ end ~}}

            {{~ for handler in OpenGenericNotificationMessageHandlers ~}}
            {{ handler.OpenGenericServiceRegistrationBlock }}
            {{~ end ~}}

            {{~ if ServiceLifetimeIsScoped || ServiceLifetimeIsTransient ~}}
            services.Add(new SD(typeof({{ NotificationPublisherType.FullName }}), typeof({{ NotificationPublisherType.FullName }}), {{ ServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.INotificationPublisher), sp => sp.GetRequiredService<{{ NotificationPublisherType.FullName }}>(), {{ ServiceLifetime }}));
            {{ else }}
            services.Add(new SD(typeof({{ NotificationPublisherType.FullName }}), typeof({{ NotificationPublisherType.FullName }}), {{ SingletonServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.INotificationPublisher), sp => sp.GetRequiredService<{{ NotificationPublisherType.FullName }}>(), {{ SingletonServiceLifetime }}));
            {{~ end ~}}

            services.Add(new SD(typeof(global::{{ MediatorNamespace }}.IContainerProbe), typeof(global::{{ MediatorNamespace }}.ContainerProbe0), {{ ServiceLifetime }}));
            services.Add(new SD(typeof(global::{{ MediatorNamespace }}.IContainerProbe), typeof(global::{{ MediatorNamespace }}.ContainerProbe1), {{ ServiceLifetime }}));

            services.Add(new SD(typeof(global::{{ MediatorNamespace }}.ContainerMetadata), typeof(global::{{ MediatorNamespace }}.ContainerMetadata), {{ SingletonServiceLifetime }}));

            return services;

			{{~ if HasNotifications ~}}
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            static global::System.Func<global::System.IServiceProvider, T> GetRequiredService<T>() where T : notnull => sp => sp.GetRequiredService<T>();
			{{~ end ~}}
        }
    }
}

namespace {{ MediatorNamespace }}
{
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    internal interface IMessageHandlerBase
    {
        global::System.Threading.Tasks.ValueTask<object?> Handle(object request, global::System.Threading.CancellationToken cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    internal interface IStreamMessageHandlerBase
    {
        global::System.Collections.Generic.IAsyncEnumerable<object?> Handle(object request, global::System.Threading.CancellationToken cancellationToken);
    }

    {{~ for wrapperType in RequestMessageHandlerWrappers ~}}
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    internal interface I{{ wrapperType.MessageType }}HandlerBase<TResponse> : {{ wrapperType.HandlerBase }}
    {
        {{ wrapperType.ReturnTypeName }} Handle(global::Mediator.I{{ wrapperType.MessageType }}<TResponse> request, global::System.Threading.CancellationToken cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class {{ wrapperType.ClassHandlerWrapperTypeNameWithGenericTypeArguments }} : I{{ wrapperType.MessageType }}HandlerBase<TResponse>
        where TRequest : class, global::Mediator.I{{ wrapperType.MessageType }}<TResponse>
    {
        private readonly {{ wrapperType.MessageHandlerDelegateName }} _rootHandler;

        public {{ wrapperType.ClassHandlerWrapperTypeName }}(
            global::Mediator.I{{ wrapperType.MessageType }}Handler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<{{ wrapperType.PipelineHandlerTypeName }}> pipelineBehaviours
        )
        {
            var handler = ({{ wrapperType.MessageHandlerDelegateName }})concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, handlerCopy, cancellationToken);
            }

            _rootHandler = handler;
        }

        public {{ wrapperType.ReturnTypeName }} Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);

        public {{ wrapperType.ReturnTypeName }} Handle(global::Mediator.I{{ wrapperType.MessageType }}<TResponse> request, global::System.Threading.CancellationToken cancellationToken) =>
            Handle((TRequest)request, cancellationToken);

        {{~ if wrapperType.IsStreaming ~}}
        public async {{ wrapperType.ReturnTypeNameWhenObject }} Handle(object request, [global::System.Runtime.CompilerServices.EnumeratorCancellation] global::System.Threading.CancellationToken cancellationToken)
        {
            await foreach (var el in Handle((TRequest)request, cancellationToken))
                yield return el;
        }
        {{~ else ~}}
        public async {{ wrapperType.ReturnTypeNameWhenObject }} Handle(object request, global::System.Threading.CancellationToken cancellationToken) =>
            await Handle((TRequest)request, cancellationToken);
        {{~ end ~}}
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class {{ wrapperType.StructHandlerWrapperTypeNameWithGenericTypeArguments }} : I{{ wrapperType.MessageType }}HandlerBase<TResponse>
        where TRequest : struct, global::Mediator.I{{ wrapperType.MessageType }}<TResponse>
    {
        private readonly {{ wrapperType.MessageHandlerDelegateName }} _rootHandler;

        public {{ wrapperType.StructHandlerWrapperTypeName }}(
            global::Mediator.I{{ wrapperType.MessageType }}Handler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<{{ wrapperType.PipelineHandlerTypeName }}> pipelineBehaviours
        )
        {
            var handler = ({{ wrapperType.MessageHandlerDelegateName }})concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, handlerCopy, cancellationToken);
            }

            _rootHandler = handler;
        }

        public {{ wrapperType.ReturnTypeName }} Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);

        public {{ wrapperType.ReturnTypeName }} Handle(global::Mediator.I{{ wrapperType.MessageType }}<TResponse> request, global::System.Threading.CancellationToken cancellationToken) =>
            Handle((TRequest)request, cancellationToken);

        {{~ if wrapperType.IsStreaming ~}}
        public async {{ wrapperType.ReturnTypeNameWhenObject }} Handle(object request, [global::System.Runtime.CompilerServices.EnumeratorCancellation] global::System.Threading.CancellationToken cancellationToken)
        {
            await foreach (var el in Handle((TRequest)request, cancellationToken))
                yield return el;
        }
        {{~ else ~}}
        public async {{ wrapperType.ReturnTypeNameWhenObject }} Handle(object request, global::System.Threading.CancellationToken cancellationToken) =>
            await Handle((TRequest)request, cancellationToken);
        {{~ end ~}}
    }
    {{~ end ~}}

    internal interface IContainerProbe { }
    internal sealed class ContainerProbe0 : IContainerProbe { }
    internal sealed class ContainerProbe1 : IContainerProbe { }

    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class ContainerMetadata
    {
        public readonly bool ServicesUnderlyingTypeIsArray;

        public readonly global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type> RequestHandlerTypes;
        public readonly global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type> CommandHandlerTypes;
        public readonly global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type> QueryHandlerTypes;

        public readonly global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type> StreamRequestHandlerTypes;
        public readonly global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type> StreamCommandHandlerTypes;
        public readonly global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type> StreamQueryHandlerTypes;

        public ContainerMetadata(global::System.IServiceProvider sp)
        {
            {{~ if ServiceLifetimeIsScoped ~}}
            using (var scope = sp.CreateScope())
            {
                ServicesUnderlyingTypeIsArray = scope.ServiceProvider.GetServices<global::{{ MediatorNamespace }}.IContainerProbe>() is global::{{ MediatorNamespace }}.IContainerProbe[];
            }
            {{~ else ~}}
            ServicesUnderlyingTypeIsArray = sp.GetServices<global::{{ MediatorNamespace }}.IContainerProbe>() is global::{{ MediatorNamespace }}.IContainerProbe[];
            {{~ end ~}}

            RequestHandlerTypes = new global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type>();
            CommandHandlerTypes = new global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type>();
            QueryHandlerTypes = new global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type>();
            {{~ for message in IRequestMessages ~}}
            RequestHandlerTypes.Add(typeof({{ message.FullName }}), typeof({{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}));
            {{~ end ~}}
            {{~ for message in ICommandMessages ~}}
            CommandHandlerTypes.Add(typeof({{ message.FullName }}), typeof({{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}));
            {{~ end ~}}
            {{~ for message in IQueryMessages ~}}
            QueryHandlerTypes.Add(typeof({{ message.FullName }}), typeof({{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}));
            {{~ end ~}}

            StreamRequestHandlerTypes = new global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type>();
            StreamCommandHandlerTypes = new global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type>();
            StreamQueryHandlerTypes = new global::System.Collections.Generic.Dictionary<global::System.Type, global::System.Type>();
            {{~ for message in IStreamRequestMessages ~}}
            StreamRequestHandlerTypes.Add(typeof({{ message.FullName }}), typeof({{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}));
            {{~ end ~}}
            {{~ for message in IStreamCommandMessages ~}}
            StreamCommandHandlerTypes.Add(typeof({{ message.FullName }}), typeof({{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}));
            {{~ end ~}}
            {{~ for message in IStreamQueryMessages ~}}
            StreamQueryHandlerTypes.Add(typeof({{ message.FullName }}), typeof({{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}));
            {{~ end ~}}
        }
    }

    /// <summary>
    /// Generated code for Mediator implementation.
    /// This type is also registered as a DI service.
    /// Can be used directly for high performance scenarios.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    public sealed partial class Mediator : global::Mediator.IMediator, global::Mediator.ISender, global::Mediator.IPublisher
    {
        private readonly global::System.IServiceProvider _sp;
        private readonly global::{{ MediatorNamespace }}.ContainerMetadata _containerMetadata;

        {{~ if ServiceLifetimeIsSingleton ~}}
        {{ if IsTestRun }}internal{{ else }}private{{ end }} FastLazyValue<DICache> _diCacheLazy;
        {{~ else ~}}
        {{ if IsTestRun }}internal{{ else }}private{{ end }} DICache _diCache;
        {{~ end ~}}

        /// <summary>
        /// The lifetime of Mediator-related service registrations in DI container.
        /// </summary>
        public const global::Microsoft.Extensions.DependencyInjection.ServiceLifetime ServiceLifetime = {{ ServiceLifetime }};

        /// <summary>
        /// The name of the notification publisher service that was configured.
        /// </summary>
        public const string NotificationPublisherName = "{{ NotificationPublisherType.Name }}";

        /// <summary>
        /// Constructor for DI, should not be used by consumer.
        /// </summary>
        public Mediator(global::System.IServiceProvider sp)
        {
            _sp = sp;
            _containerMetadata = sp.GetRequiredService<global::{{ MediatorNamespace }}.ContainerMetadata>();
            {{~ if ServiceLifetimeIsSingleton ~}}
            _diCacheLazy = new FastLazyValue<DICache>(() => new DICache(_sp, _containerMetadata));
            {{~ else ~}}
            _diCache = new DICache(_sp, _containerMetadata);
            {{~ end ~}}
        }

        {{~ if ServiceLifetimeIsSingleton ~}}
        {{ if IsTestRun }}internal{{ else }}private{{ end }} struct FastLazyValue<T>
        {
            {{ if IsTestRun }}internal{{ else }}private{{ end }} const long UNINIT = 0;
            {{ if IsTestRun }}internal{{ else }}private{{ end }} const long INITING = 1;
            {{ if IsTestRun }}internal{{ else }}private{{ end }} const long INITD = 2;
            {{ if IsTestRun }}internal const long INVALID = -1;{{ end }}
            {{ if IsTestRun }}internal const long CACHED = 3;{{ end }}

            {{ if IsTestRun }}internal{{ else }}private{{ end }} global::System.Func<T> _generator;
            {{ if IsTestRun }}internal{{ else }}private{{ end }} long _state;
            {{ if IsTestRun }}internal{{ else }}private{{ end }} T _value;

            public T Value
            {
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                get
                {
                    if (_state != INITD)
                        return ValueSlow;

                    return _value;
                }
            }

            {{ if IsTestRun }}internal{{ else }}private{{ end }} T ValueSlow
            {
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
                get
                {
                    var prevState = global::System.Threading.Interlocked.CompareExchange(ref _state, INITING, UNINIT);
                    switch (prevState)
                    {
                        case INITD:
                            // Someone has already completed init
                            return _value;
                        case INITING:
                            // Wait for someone else to complete
                            var spinWait = default(global::System.Threading.SpinWait);
                            while (global::System.Threading.Interlocked.Read(ref _state) < INITD)
                                spinWait.SpinOnce();
                            return _value;
                        case UNINIT:
                            _value = _generator();
                            global::System.Threading.Interlocked.Exchange(ref _state, INITD);
                            return _value;
                    }

                    return _value;
                }
            }

            {{~ if IsTestRun ~}}
            internal (T, long) ValueInstrumented
            {
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                get
                {
                    if (_state != INITD)
                        return ValueSlowInstrumented;

                    return (_value, CACHED);
                }
            }

            internal (T, long) ValueSlowInstrumented
            {
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
                get
                {
                    var prevState = global::System.Threading.Interlocked.CompareExchange(ref _state, INITING, UNINIT);
                    switch (prevState)
                    {
                        case INITD:
                            // Someone has already completed init
                            return (_value, INITD);
                        case INITING:
                            // Wait for someone else to complete
                            var spinWait = default(global::System.Threading.SpinWait);
                            while (global::System.Threading.Interlocked.Read(ref _state) < INITD)
                                spinWait.SpinOnce();
                            return (_value, INITING);
                        case UNINIT:
                            _value = _generator();
                            global::System.Threading.Interlocked.Exchange(ref _state, INITD);
                            return (_value, UNINIT);
                    }

                    return (_value, INVALID);
                }
            }
            {{~ end ~}}

            public FastLazyValue(global::System.Func<T> generator)
            {
                _generator = generator;
                _state = UNINIT;
                _value = default!;
            }
        }
        {{~ end ~}}

        {{ if IsTestRun }}internal{{ else }}private{{ end }} sealed class DICache
        {
            private readonly global::System.IServiceProvider _sp;
            private readonly global::{{ MediatorNamespace }}.ContainerMetadata _containerMetadata;

            {{~ if HasManyRequests ~}}
            {{~ if ServiceLifetimeIsSingleton ~}}
            public readonly global::System.Collections.Generic.Dictionary<global::System.Type, object> RequestHandlers;
            {{~ else ~}}
            public readonly global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object> RequestHandlers;
            {{~ end ~}}
            public object GetRequestHandler(global::System.Type type)
            {
                {{~ if ServiceLifetimeIsSingleton ~}}
                if (!RequestHandlers.TryGetValue(type, out var handler))
                    throw new global::System.InvalidOperationException();
                return handler;
                {{~ else ~}}
                return RequestHandlers.GetOrAdd(type, (type, self) =>
                {
                    var diCache = (DICache)self;
                    if (!diCache._containerMetadata.RequestHandlerTypes.TryGetValue(type, out var handlerType))
                        throw new global::System.InvalidOperationException();

                    return diCache._sp.GetRequiredService(handlerType);
                }, this);
                {{~ end ~}}
            }
            {{~ end ~}}

            {{~ if HasManyCommands ~}}
            {{~ if ServiceLifetimeIsSingleton ~}}
            public readonly global::System.Collections.Generic.Dictionary<global::System.Type, object> CommandHandlers;
            {{~ else ~}}
            public readonly global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object> CommandHandlers;
            {{~ end ~}}
            public object GetCommandHandler(global::System.Type type)
            {
                {{~ if ServiceLifetimeIsSingleton ~}}
                if (!CommandHandlers.TryGetValue(type, out var handler))
                    throw new global::System.InvalidOperationException();
                return handler;
                {{~ else ~}}
                return CommandHandlers.GetOrAdd(type, (type, self) =>
                {
                    var diCache = (DICache)self;
                    if (!diCache._containerMetadata.CommandHandlerTypes.TryGetValue(type, out var handlerType))
                        throw new global::System.InvalidOperationException();

                    return diCache._sp.GetRequiredService(handlerType);
                }, this);
                {{~ end ~}}
            }
            {{~ end ~}}

            {{~ if HasManyQueries ~}}
            {{~ if ServiceLifetimeIsSingleton ~}}
            public readonly global::System.Collections.Generic.Dictionary<global::System.Type, object> QueryHandlers;
            {{~ else ~}}
            public readonly global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object> QueryHandlers;
            {{~ end ~}}
            public object GetQueryHandler(global::System.Type type)
            {
                {{~ if ServiceLifetimeIsSingleton ~}}
                if (!QueryHandlers.TryGetValue(type, out var handler))
                    throw new global::System.InvalidOperationException();
                return handler;
                {{~ else ~}}
                return QueryHandlers.GetOrAdd(type, (type, self) =>
                {
                    var diCache = (DICache)self;
                    if (!diCache._containerMetadata.QueryHandlerTypes.TryGetValue(type, out var handlerType))
                        throw new global::System.InvalidOperationException();

                    return diCache._sp.GetRequiredService(handlerType);
                }, this);
                {{~ end ~}}
            }
            {{~ end ~}}


            {{~ if HasManyStreamRequests ~}}
            {{~ if ServiceLifetimeIsSingleton ~}}
            public readonly global::System.Collections.Generic.Dictionary<global::System.Type, object> StreamRequestHandlers;
            {{~ else ~}}
            public readonly global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object> StreamRequestHandlers;
            {{~ end ~}}
            public object GetStreamRequestHandler(global::System.Type type)
            {
                {{~ if ServiceLifetimeIsSingleton ~}}
                if (!StreamRequestHandlers.TryGetValue(type, out var handler))
                    throw new global::System.InvalidOperationException();
                return handler;
                {{~ else ~}}
                return StreamRequestHandlers.GetOrAdd(type, (type, self) =>
                {
                    var diCache = (DICache)self;
                    if (!diCache._containerMetadata.StreamRequestHandlerTypes.TryGetValue(type, out var handlerType))
                        throw new global::System.InvalidOperationException();

                    return diCache._sp.GetRequiredService(handlerType);
                }, this);
                {{~ end ~}}
            }
            {{~ end ~}}

            {{~ if HasManyStreamCommands ~}}
            {{~ if ServiceLifetimeIsSingleton ~}}
            public readonly global::System.Collections.Generic.Dictionary<global::System.Type, object> StreamCommandHandlers;
            {{~ else ~}}
            public readonly global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object> StreamCommandHandlers;
            {{~ end ~}}
            public object GetStreamCommandHandler(global::System.Type type)
            {
                {{~ if ServiceLifetimeIsSingleton ~}}
                if (!StreamCommandHandlers.TryGetValue(type, out var handler))
                    throw new global::System.InvalidOperationException();
                return handler;
                {{~ else ~}}
                return StreamCommandHandlers.GetOrAdd(type, (type, self) =>
                {
                    var diCache = (DICache)self;
                    if (!diCache._containerMetadata.StreamCommandHandlerTypes.TryGetValue(type, out var handlerType))
                        throw new global::System.InvalidOperationException();

                    return diCache._sp.GetRequiredService(handlerType);
                }, this);
                {{~ end ~}}
            }
            {{~ end ~}}

            {{~ if HasManyStreamQueries ~}}
            {{~ if ServiceLifetimeIsSingleton ~}}
            public readonly global::System.Collections.Generic.Dictionary<global::System.Type, object> StreamQueryHandlers;
            {{~ else ~}}
            public readonly global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object> StreamQueryHandlers;
            {{~ end ~}}
            public object GetStreamQueryHandler(global::System.Type type)
            {
                {{~ if ServiceLifetimeIsSingleton ~}}
                if (!StreamQueryHandlers.TryGetValue(type, out var handler))
                    throw new global::System.InvalidOperationException();
                return handler;
                {{~ else ~}}
                return StreamQueryHandlers.GetOrAdd(type, (type, self) =>
                {
                    var diCache = (DICache)self;
                    if (!diCache._containerMetadata.StreamQueryHandlerTypes.TryGetValue(type, out var handlerType))
                        throw new global::System.InvalidOperationException();

                    return diCache._sp.GetRequiredService(handlerType);
                }, this);
                {{~ end ~}}
            }
            {{~ end ~}}

            {{~ if ServiceLifetimeIsSingleton ~}}
            {{~ for message in RequestMessages ~}}
            public readonly {{ message.HandlerWrapperTypeNameWithGenericTypeArguments }} {{ message.HandlerWrapperPropertyName }};
            {{~ end ~}}
            {{~ else ~}}
            {{~ for message in RequestMessages ~}}
            public {{ message.HandlerWrapperTypeNameWithGenericTypeArguments }} {{ message.HandlerWrapperPropertyName }}
            {
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                get => _sp.GetRequiredService<{{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}>();
            }
            {{~ end ~}}
            {{~ end ~}}

            {{~ if ServiceLifetimeIsSingleton ~}}

            {{~ for message in NotificationMessages ~}}
            public readonly global::Mediator.INotificationHandler<{{ message.FullName }}>[] Handlers_For_{{ message.IdentifierFullName }};
            {{~ end ~}}

            public readonly {{ NotificationPublisherType.FullName }} InternalNotificationPublisherImpl;
            {{~ else ~}}

            {{~ for message in NotificationMessages ~}}
            public global::System.Collections.Generic.IEnumerable<global::Mediator.INotificationHandler<{{ message.FullName }}>> Handlers_For_{{ message.IdentifierFullName }}
            {
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                get => _sp.GetServices<global::Mediator.INotificationHandler<{{ message.FullName }}>>();
            }
            {{~ end ~}}

            public {{ NotificationPublisherType.FullName }} InternalNotificationPublisherImpl
            {
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                get => _sp.GetRequiredService<{{ NotificationPublisherType.FullName }}>();
            }
            {{~ end ~}}

            public DICache(global::System.IServiceProvider sp, global::{{ MediatorNamespace }}.ContainerMetadata containerMetadata)
            {
                _sp = sp;
                _containerMetadata = containerMetadata;

                {{~ if HasManyRequests ~}}
                {{~ if ServiceLifetimeIsSingleton ~}}
                RequestHandlers = new global::System.Collections.Generic.Dictionary<global::System.Type, object>();
                {{~ for message in IRequestMessages ~}}
                RequestHandlers.Add(typeof({{ message.FullName }}), sp.GetRequiredService(_containerMetadata.RequestHandlerTypes[typeof({{ message.FullName }})]));
                {{~ end ~}}
                {{~ else ~}}
                RequestHandlers = new global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object>();
                {{~ end ~}}
                {{~ end ~}}

                {{~ if HasManyCommands ~}}
                {{~ if ServiceLifetimeIsSingleton ~}}
                CommandHandlers = new global::System.Collections.Generic.Dictionary<global::System.Type, object>();
                {{~ for message in ICommandMessages ~}}
                CommandHandlers.Add(typeof({{ message.FullName }}), sp.GetRequiredService(_containerMetadata.CommandHandlerTypes[typeof({{ message.FullName }})]));
                {{~ end ~}}
                {{~ else ~}}
                CommandHandlers = new global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object>();
                {{~ end ~}}
                {{~ end ~}}

                {{~ if HasManyQueries ~}}
                {{~ if ServiceLifetimeIsSingleton ~}}
                QueryHandlers = new global::System.Collections.Generic.Dictionary<global::System.Type, object>();
                {{~ for message in IQueryMessages ~}}
                QueryHandlers.Add(typeof({{ message.FullName }}), sp.GetRequiredService(_containerMetadata.QueryHandlerTypes[typeof({{ message.FullName }})]));
                {{~ end ~}}
                {{~ else ~}}
                QueryHandlers = new global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object>();
                {{~ end ~}}
                {{~ end ~}}

                {{~ if HasManyStreamRequests ~}}
                {{~ if ServiceLifetimeIsSingleton ~}}
                StreamRequestHandlers = new global::System.Collections.Generic.Dictionary<global::System.Type, object>();
                {{~ for message in IStreamRequestMessages ~}}
                StreamRequestHandlers.Add(typeof({{ message.FullName }}), sp.GetRequiredService(_containerMetadata.StreamRequestHandlerTypes[typeof({{ message.FullName }})]));
                {{~ end ~}}
                {{~ else ~}}
                StreamRequestHandlers = new global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object>();
                {{~ end ~}}
                {{~ end ~}}

                {{~ if HasManyStreamCommands ~}}
                {{~ if ServiceLifetimeIsSingleton ~}}
                StreamCommandHandlers = new global::System.Collections.Generic.Dictionary<global::System.Type, object>();
                {{~ for message in IStreamCommandMessages ~}}
                StreamCommandHandlers.Add(typeof({{ message.FullName }}), sp.GetRequiredService(_containerMetadata.StreamCommandHandlerTypes[typeof({{ message.FullName }})]));
                {{~ end ~}}
                {{~ else ~}}
                StreamCommandHandlers = new global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object>();
                {{~ end ~}}
                {{~ end ~}}

                {{~ if HasManyStreamQueries ~}}
                {{~ if ServiceLifetimeIsSingleton ~}}
                StreamQueryHandlers = new global::System.Collections.Generic.Dictionary<global::System.Type, object>();
                {{~ for message in IStreamQueryMessages ~}}
                StreamQueryHandlers.Add(typeof({{ message.FullName }}), sp.GetRequiredService(_containerMetadata.StreamQueryHandlerTypes[typeof({{ message.FullName }})]));
                {{~ end ~}}
                {{~ else ~}}
                StreamQueryHandlers = new global::System.Collections.Concurrent.ConcurrentDictionary<global::System.Type, object>();
                {{~ end ~}}
                {{~ end ~}}

                {{~ if ServiceLifetimeIsSingleton ~}}

                {{~ for message in RequestMessages ~}}
                {{ message.HandlerWrapperPropertyName }} = sp.GetRequiredService<{{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}>();
                {{~ end ~}}

                {{~ end ~}}

                {{~ for message in NotificationMessages ~}}
                var handlers_For_{{ message.IdentifierFullName }} = sp.GetServices<global::Mediator.INotificationHandler<{{ message.FullName }}>>();
                if (containerMetadata.ServicesUnderlyingTypeIsArray)
                {
                    global::System.Diagnostics.Debug.Assert(handlers_For_{{ message.IdentifierFullName }} is global::Mediator.INotificationHandler<{{ message.FullName }}>[]);
                    Handlers_For_{{ message.IdentifierFullName }} = global::System.Runtime.CompilerServices.Unsafe.As<global::Mediator.INotificationHandler<{{ message.FullName }}>[]>(
                        handlers_For_{{ message.IdentifierFullName }}
                    );
                }
                else
                {
                    global::System.Diagnostics.Debug.Assert(handlers_For_{{ message.IdentifierFullName }} is not global::Mediator.INotificationHandler<{{ message.FullName }}>[]);
                    Handlers_For_{{ message.IdentifierFullName }} = handlers_For_{{ message.IdentifierFullName }}.ToArray();
                }
                {{~ end ~}}

                {{~ if ServiceLifetimeIsSingleton ~}}
                InternalNotificationPublisherImpl = sp.GetRequiredService<{{ NotificationPublisherType.FullName }}>();
                {{~ end ~}}
            }
        }

        {{~ for message in RequestMessages ~}}
        /// <summary>
        /// Send a message of type {{ message.RequestFullName }}.
        {{- if message.IsClass }}
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        {{- end }}
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        {{ message.AccessibilityModifier }} {{ message.AsyncReturnType }} {{ message.AsyncMethodName }}(
            {{ message.ParameterModifier -}}{{ message.RequestFullName }} message,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if message.IsClass }}
            ThrowIfNull(message, nameof(message));
            {{- end }}
            return {{ DICacheFieldName }}.{{ message.HandlerWrapperPropertyName }}.Handle({{- message.ParameterModifier -}}message, cancellationToken);
        }
        {{~ end ~}}

        /// <summary>
        /// Send request.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if request does not implement <see cref="global::Mediator.IRequest{TResponse}"/>.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="request">Incoming request</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(
            global::Mediator.IRequest<TResponse> request,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasRequests }}
            {{~ if HasManyRequests ~}}
            var handlerObj = {{ DICacheFieldName }}.GetRequestHandler(request.GetType());
            global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IRequestHandlerBase<TResponse>);
            ref var handler = ref global::System.Runtime.CompilerServices.Unsafe.As<object, global::{{ MediatorNamespace }}.IRequestHandlerBase<TResponse>>(ref handlerObj);
            return handler.Handle(request, cancellationToken);
            {{~ else ~}}
            switch (request)
            {
                {{~ for message in IRequestMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    if (typeof(TResponse) == typeof({{ message.ResponseFullNameWithoutReferenceNullability }}))
                    {
                        var task = Send({{- message.ParameterModifier -}}r, cancellationToken);
                        return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                    }
                    return SendAsync(request, cancellationToken);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidRequest(request, nameof(request));
                    return default;
                }
            }
            {{~ end ~}}
            {{- else }}
            ThrowInvalidRequest(request, nameof(request));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Send request.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="request">Incoming request</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        private {{ if !HasManyRequests }}async{{ end }} global::System.Threading.Tasks.ValueTask<TResponse> SendAsync<TResponse>(
            global::Mediator.IRequest<TResponse> request,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasRequests }}
            {{~ if HasManyRequests ~}}
            var handlerObj = {{ DICacheFieldName }}.GetRequestHandler(request.GetType());
            global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IRequestHandlerBase<TResponse>);
            ref var handler = ref global::System.Runtime.CompilerServices.Unsafe.As<object, global::{{ MediatorNamespace }}.IRequestHandlerBase<TResponse>>(ref handlerObj);
            return handler.Handle(request, cancellationToken);
            {{~ else ~}}
            switch (request)
            {
                {{~ for message in IRequestMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var response = await Send({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.ResponseFullName }}, TResponse>(ref response);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidRequest(request, nameof(request));
                    return default;
                }
            }
            {{~ end ~}}
            {{- else }}
            ThrowInvalidRequest(request, nameof(request));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Create stream for request.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if request does not implement <see cref="global::Mediator.IStreamRequest{TResponse}"/>.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="request">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(
            global::Mediator.IStreamRequest<TResponse> request,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasStreamRequests }}
            {{- if HasManyStreamRequests }}
            var handlerObj = {{ DICacheFieldName }}.GetStreamRequestHandler(request.GetType());
            global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IStreamRequestHandlerBase<TResponse>);
            ref var handler = ref global::System.Runtime.CompilerServices.Unsafe.As<object, global::{{ MediatorNamespace }}.IStreamRequestHandlerBase<TResponse>>(ref handlerObj);
            return handler.Handle(request, cancellationToken);
            {{~ else ~}}
            switch (request)
            {
                {{~ for message in IStreamRequestMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var task = CreateStream({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Collections.Generic.IAsyncEnumerable<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidStreamRequest(request, nameof(request));
                    return default;
                }
            }
            {{~ end ~}}
            {{- else }}
            ThrowInvalidStreamRequest(request, nameof(request));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Send command.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if command does not implement <see cref="global::Mediator.ICommand{TResponse}"/>.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="command">Incoming command</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(
            global::Mediator.ICommand<TResponse> command,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasCommands }}
            {{~ if HasManyCommands ~}}
            var handlerObj = {{ DICacheFieldName }}.GetCommandHandler(command.GetType());
            global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.ICommandHandlerBase<TResponse>);
            ref var handler = ref global::System.Runtime.CompilerServices.Unsafe.As<object, global::{{ MediatorNamespace }}.ICommandHandlerBase<TResponse>>(ref handlerObj);
            return handler.Handle(command, cancellationToken);
            {{~ else ~}}
            switch (command)
            {
                {{~ for message in ICommandMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    if (typeof(TResponse) == typeof({{ message.ResponseFullNameWithoutReferenceNullability }}))
                    {
                        var task = Send({{- message.ParameterModifier -}}r, cancellationToken);
                        return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                    }
                    return SendAsync(command, cancellationToken);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidCommand(command, nameof(command));
                    return default;
                }
            }
            {{~ end ~}}
            {{- else }}
            ThrowInvalidCommand(command, nameof(command));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Send command.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="command">Incoming command</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        private {{ if !HasManyCommands }}async{{ end }} global::System.Threading.Tasks.ValueTask<TResponse> SendAsync<TResponse>(
            global::Mediator.ICommand<TResponse> command,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasCommands }}
            {{~ if HasManyCommands ~}}
            var handlerObj = {{ DICacheFieldName }}.GetCommandHandler(command.GetType());
            global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.ICommandHandlerBase<TResponse>);
            ref var handler = ref global::System.Runtime.CompilerServices.Unsafe.As<object, global::{{ MediatorNamespace }}.ICommandHandlerBase<TResponse>>(ref handlerObj);
            return handler.Handle(command, cancellationToken);
            {{~ else ~}}
            switch (command)
            {
                {{~ for message in ICommandMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var response = await Send({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.ResponseFullName }}, TResponse>(ref response);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidCommand(command, nameof(command));
                    return default;
                }
            }
            {{~ end ~}}
            {{- else }}
            ThrowInvalidCommand(command, nameof(command));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Create stream for command.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if command does not implement <see cref="global::Mediator.IStreamCommand{TResponse}"/>.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="command">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(
            global::Mediator.IStreamCommand<TResponse> command,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasStreamCommands }}
            {{- if HasManyStreamCommands }}
            var handlerObj = {{ DICacheFieldName }}.GetStreamCommandHandler(command.GetType());
            global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IStreamCommandHandlerBase<TResponse>);
            ref var handler = ref global::System.Runtime.CompilerServices.Unsafe.As<object, global::{{ MediatorNamespace }}.IStreamCommandHandlerBase<TResponse>>(ref handlerObj);
            return handler.Handle(command, cancellationToken);
            {{~ else ~}}
            switch (command)
            {
                {{~ for message in IStreamCommandMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var task = CreateStream({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Collections.Generic.IAsyncEnumerable<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidStreamCommand(command, nameof(command));
                    return default;
                }
            }
            {{~ end ~}}
            {{- else }}
            ThrowInvalidStreamCommand(command, nameof(command));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Send query.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if query does not implement <see cref="global::Mediator.IQuery{TResponse}"/>.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="query">Incoming query</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(
            global::Mediator.IQuery<TResponse> query,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasQueries }}
            {{~ if HasManyQueries ~}}
            var handlerObj = {{ DICacheFieldName }}.GetQueryHandler(query.GetType());
            global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IQueryHandlerBase<TResponse>);
            ref var handler = ref global::System.Runtime.CompilerServices.Unsafe.As<object, global::{{ MediatorNamespace }}.IQueryHandlerBase<TResponse>>(ref handlerObj);
            return handler.Handle(query, cancellationToken);
            {{~ else ~}}
            switch (query)
            {
                {{~ for message in IQueryMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    if (typeof(TResponse) == typeof({{ message.ResponseFullNameWithoutReferenceNullability }}))
                    {
                        var task = Send({{- message.ParameterModifier -}}r, cancellationToken);
                        return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                    }
                    return SendAsync(query, cancellationToken);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidQuery(query, nameof(query));
                    return default;
                }
            }
            {{~ end ~}}
            {{- else }}
            ThrowInvalidQuery(query, nameof(query));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Send query.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="query">Incoming query</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        private {{ if !HasManyQueries }}async{{ end }} global::System.Threading.Tasks.ValueTask<TResponse> SendAsync<TResponse>(
            global::Mediator.IQuery<TResponse> query,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasQueries }}
            {{~ if HasManyQueries ~}}
            var handlerObj = {{ DICacheFieldName }}.GetQueryHandler(query.GetType());
            global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IQueryHandlerBase<TResponse>);
            ref var handler = ref global::System.Runtime.CompilerServices.Unsafe.As<object, global::{{ MediatorNamespace }}.IQueryHandlerBase<TResponse>>(ref handlerObj);
            return handler.Handle(query, cancellationToken);
            {{~ else ~}}
            switch (query)
            {
                {{~ for message in IQueryMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var response = await Send({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.ResponseFullName }}, TResponse>(ref response);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidQuery(query, nameof(query));
                    return default;
                }
            }
            {{~ end ~}}
            {{- else }}
            ThrowInvalidQuery(query, nameof(query));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Create stream for query.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if query does not implement <see cref="global::Mediator.IStreamQuery{TResponse}"/>.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="query">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(
            global::Mediator.IStreamQuery<TResponse> query,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasStreamQueries }}
            {{- if HasManyStreamQueries }}
            var handlerObj = {{ DICacheFieldName }}.GetStreamQueryHandler(query.GetType());
            global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IStreamQueryHandlerBase<TResponse>);
            ref var handler = ref global::System.Runtime.CompilerServices.Unsafe.As<object, global::{{ MediatorNamespace }}.IStreamQueryHandlerBase<TResponse>>(ref handlerObj);
            return handler.Handle(query, cancellationToken);
            {{~ else ~}}
            switch (query)
            {
                {{~ for message in IStreamQueryMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var task = CreateStream({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Collections.Generic.IAsyncEnumerable<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidStreamQuery(query, nameof(query));
                    return default;
                }
            }
            {{~ end ~}}
            {{- else }}
            ThrowInvalidStreamQuery(query, nameof(query));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Send message.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if message does not implement <see cref="global::Mediator.IMessage"/>.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public{{ if HasAnyRequest; " async "; else; " "; end; }}global::System.Threading.Tasks.ValueTask<object?> Send(
            object message,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasAnyRequest }}
            switch (message)
            {
                case global::Mediator.IBaseRequest request:
                    {{~ if HasManyRequests ~}}
                    var handlerObj = {{ DICacheFieldName }}.GetRequestHandler(request.GetType());
                    global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IMessageHandlerBase);
                    var handler = global::System.Runtime.CompilerServices.Unsafe.As<global::{{ MediatorNamespace }}.IMessageHandlerBase>(handlerObj);
                    return await handler.Handle(request, cancellationToken);
                    {{~ else ~}}
                    switch (request)
                    {
                        {{~ for message in IRequestMessages ~}}
                        case {{ message.RequestFullName }} r: return await Send({{- message.ParameterModifier -}}r, cancellationToken);
                        {{~ end ~}}
                        default:
                        {
                            ThrowInvalidRequest(request, nameof(request));
                            return default;
                        }
                    }
                    {{~ end ~}}
                case global::Mediator.IBaseCommand command:
                    {{~ if HasManyCommands ~}}
                    var handlerObj = {{ DICacheFieldName }}.GetCommandHandler(command.GetType());
                    global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IMessageHandlerBase);
                    var handler = global::System.Runtime.CompilerServices.Unsafe.As<global::{{ MediatorNamespace }}.IMessageHandlerBase>(handlerObj);
                    return await handler.Handle(command, cancellationToken);
                    {{~ else ~}}
                    switch (command)
                    {
                        {{~ for message in ICommandMessages ~}}
                        case {{ message.RequestFullName }} r: return await Send({{- message.ParameterModifier -}}r, cancellationToken);
                        {{~ end ~}}
                        default:
                        {
                            ThrowInvalidCommand(command, nameof(command));
                            return default;
                        }
                    }
                    {{~ end ~}}
                case global::Mediator.IBaseQuery query:
                    {{~ if HasManyQueries ~}}
                    var handlerObj = {{ DICacheFieldName }}.GetQueryHandler(query.GetType());
                    global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IMessageHandlerBase);
                    var handler = global::System.Runtime.CompilerServices.Unsafe.As<global::{{ MediatorNamespace }}.IMessageHandlerBase>(handlerObj);
                    return await handler.Handle(query, cancellationToken);
                    {{~ else ~}}
                    switch (query)
                    {
                        {{~ for message in IQueryMessages ~}}
                        case {{ message.RequestFullName }} r: return await Send({{- message.ParameterModifier -}}r, cancellationToken);
                        {{~ end ~}}
                        default:
                        {
                            ThrowInvalidQuery(query, nameof(query));
                            return default;
                        }
                    }
                    {{~ end ~}}
                default:
                    ThrowInvalidMessage(message, nameof(message));
                    return default;
            }
            {{- else }}
            ThrowInvalidMessage(message, nameof(message));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Create stream.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if message does not implement <see cref="global::Mediator.IStreamMessage"/>.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<object?> CreateStream(
            object message,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasAnyStreamRequest }}
            switch (message)
            {
                case global::Mediator.IBaseStreamRequest request:
                    {{~ if HasManyStreamRequests ~}}
                    var handlerObj = {{ DICacheFieldName }}.GetStreamRequestHandler(request.GetType());
                    global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IStreamMessageHandlerBase);
                    var handler = global::System.Runtime.CompilerServices.Unsafe.As<global::{{ MediatorNamespace }}.IStreamMessageHandlerBase>(handlerObj);
                    return handler.Handle(request, cancellationToken);
                    {{~ else ~}}
                    switch (request)
                    {
                        {{~ for message in IStreamRequestMessages ~}}
                        case {{ message.RequestFullName }} m:
                        {
                            {{- if message.ResponseIsValueType }}
                            var value = CreateStream({{- message.ParameterModifier -}}m, cancellationToken);
                            return AsyncWrapper(value);
                            {{- else }}
                            return CreateStream({{- message.ParameterModifier -}}m, cancellationToken);
                            {{- end }}
                        }
                        {{~ end ~}}
                        default:
                        {
                            ThrowInvalidStreamMessage(message, nameof(message));
                            return default;
                        }
                    }
                    {{~ end ~}}
                case global::Mediator.IBaseStreamCommand command:
                    {{~ if HasManyStreamCommands ~}}
                    var handlerObj = {{ DICacheFieldName }}.GetStreamCommandHandler(command.GetType());
                    global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IStreamMessageHandlerBase);
                    var handler = global::System.Runtime.CompilerServices.Unsafe.As<global::{{ MediatorNamespace }}.IStreamMessageHandlerBase>(handlerObj);
                    return handler.Handle(command, cancellationToken);
                    {{~ else ~}}
                    switch (command)
                    {
                        {{~ for message in IStreamCommandMessages ~}}
                        case {{ message.CommandFullName }} m:
                        {
                            {{- if message.ResponseIsValueType }}
                            var value = CreateStream({{- message.ParameterModifier -}}m, cancellationToken);
                            return AsyncWrapper(value);
                            {{- else }}
                            return CreateStream({{- message.ParameterModifier -}}m, cancellationToken);
                            {{- end }}
                        }
                        {{~ end ~}}
                        default:
                        {
                            ThrowInvalidStreamMessage(message, nameof(message));
                            return default;
                        }
                    }
                    {{~ end ~}}

                case global::Mediator.IBaseStreamQuery query:
                    {{~ if HasManyStreamQueries ~}}
                    var handlerObj = {{ DICacheFieldName }}.GetStreamQueryHandler(query.GetType());
                    global::System.Diagnostics.Debug.Assert(handlerObj is global::{{ MediatorNamespace }}.IStreamMessageHandlerBase);
                    var handler = global::System.Runtime.CompilerServices.Unsafe.As<global::{{ MediatorNamespace }}.IStreamMessageHandlerBase>(handlerObj);
                    return handler.Handle(query, cancellationToken);
                    {{~ else ~}}
                    switch (query)
                    {
                        {{~ for message in IStreamQueryMessages ~}}
                        case {{ message.QueryFullName }} m:
                        {
                            {{- if message.ResponseIsValueType }}
                            var value = CreateStream({{- message.ParameterModifier -}}m, cancellationToken);
                            return AsyncWrapper(value);
                            {{- else }}
                            return CreateStream({{- message.ParameterModifier -}}m, cancellationToken);
                            {{- end }}
                        }
                        {{~ end ~}}
                        default:
                        {
                            ThrowInvalidStreamMessage(message, nameof(message));
                            return default;
                        }
                    }
                    {{~ end ~}}

                default:
                    ThrowInvalidStreamMessage(message, nameof(message));
                    return default;
            }

            {{- if HasAnyValueTypeStreamResponse }}
            static async global::System.Collections.Generic.IAsyncEnumerable<object?> AsyncWrapper<T>(global::System.Collections.Generic.IAsyncEnumerable<T> wrapped, [global::System.Runtime.CompilerServices.EnumeratorCancellation] global::System.Threading.CancellationToken cancellationToken = default) where T : struct
            {
                await foreach (var value in global::System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation(wrapped, cancellationToken))
                {
                    yield return value;
                }
            }
            {{ end }}

            {{- else }}
            ThrowInvalidStreamMessage(message, nameof(message));
            return default;
            {{- end }}
        }

        /// <summary>
        /// Publish notification.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if notification does not implement <see cref="global::Mediator.INotification"/>.
        /// Throws <see cref="global::System.AggregateException"/> if handlers throw exception(s).
        /// Drops messages
        /// </summary>
        /// <param name="notification">Incoming notification</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask Publish(
            object notification,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasNotifications }}
            switch (notification)
            {
                {{~ for message in NotificationMessages ~}}
                case {{ message.FullName }} n: return Publish(n, cancellationToken);
                {{~ end ~}}
                default:
                {
                    ThrowInvalidNotification(notification, nameof(notification));
                    return default;
                }
            }
            {{- else }}
            ThrowInvalidNotification(notification, nameof(notification));
            return default;
            {{- end }}
        }

        {{~ for message in NotificationMessages ~}}
        /// <summary>
        /// Send a notification of type {{ message.FullName }}.
        {{- if message.IsClass }}
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        {{- end }}
        /// Throws <see cref="global::System.AggregateException"/> if handlers throw exception(s).
        /// </summary>
        /// <param name="notification">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        {{ message.AccessibilityModifier }} global::System.Threading.Tasks.ValueTask Publish(
            {{ message.ParameterModifier -}}{{ message.FullName }} notification,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if message.IsClass }}
            ThrowIfNull(notification, nameof(notification));
            {{ end }}

            var handlers = {{ DICacheFieldName }}.Handlers_For_{{ message.IdentifierFullName }};

            {{~ if ServiceLifetimeIsSingleton ~}}
            if (handlers.Length == 0)
            {
                return default;
            }
            var publisher = {{ DICacheFieldName }}.InternalNotificationPublisherImpl;
            return publisher.Publish(
                new global::Mediator.NotificationHandlers<{{ message.FullName }}>(handlers, isArray: true),
                notification,
                cancellationToken
            );
            {{~ else ~}}
            var isArray = _containerMetadata.ServicesUnderlyingTypeIsArray;
            if (isArray)
            {
                global::System.Diagnostics.Debug.Assert(handlers is global::Mediator.INotificationHandler<{{ message.FullName }}>[]);
                if (global::System.Runtime.CompilerServices.Unsafe.As<global::Mediator.INotificationHandler<{{ message.FullName }}>[]>(handlers).Length == 0)
                {
                    return default;
                }
            }
            else
            {
                global::System.Diagnostics.Debug.Assert(handlers is not global::Mediator.INotificationHandler<{{ message.FullName }}>[]);
            }
            var publisher = _diCache.InternalNotificationPublisherImpl;
            return publisher.Publish(
                new global::Mediator.NotificationHandlers<{{ message.FullName }}>(handlers, isArray),
                notification,
                cancellationToken
            );
            {{~ end ~}}
        }
        {{~ end ~}}

        /// <summary>
        /// Publish notification.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.InvalidMessageException"/> if notification does not implement <see cref="global::Mediator.INotification"/>.
        /// Throws <see cref="global::System.AggregateException"/> if handlers throw exception(s).
        /// </summary>
        /// <param name="notification">Incoming notification</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask Publish<TNotification>(
            TNotification notification,
            global::System.Threading.CancellationToken cancellationToken = default
        )
            where TNotification : global::Mediator.INotification
        {
            {{- if HasNotifications }}
            switch (notification)
            {
                {{~ for message in NotificationMessages ~}}
                case {{ message.FullName }} n: return Publish(n, cancellationToken);
                {{~ end ~}}
                default:
                {
                    ThrowInvalidNotification(notification, nameof(notification));
                    return default;
                }
            }
            {{- else }}
            ThrowInvalidNotification(notification, nameof(notification));
            return default;
            {{- end }}
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowMissingHandler(object msg) =>
            throw new global::Mediator.MissingMessageHandlerException(msg);

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidMessage<T>(T? msg, string? paramName = null)
        {
            if (msg == null)
                ThrowArgumentNull(paramName);
            else if (!(msg is global::Mediator.IMessage))
                ThrowInvalidMessage(msg);
            else
                ThrowMissingHandler(msg);
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidRequest<T>(T? msg, string? paramName = null)
        {
            if (msg == null)
                ThrowArgumentNull(paramName);
            else if (!(msg is global::Mediator.IBaseRequest))
                ThrowInvalidMessage(msg);
            else
                ThrowMissingHandler(msg);
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidCommand<T>(T? msg, string? paramName = null)
        {
            if (msg == null)
                ThrowArgumentNull(paramName);
            else if (!(msg is global::Mediator.IBaseCommand))
                ThrowInvalidMessage(msg);
            else
                ThrowMissingHandler(msg);
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidQuery<T>(T? msg, string? paramName = null)
        {
            if (msg == null)
                ThrowArgumentNull(paramName);
            else if (!(msg is global::Mediator.IBaseQuery))
                ThrowInvalidMessage(msg);
            else
                ThrowMissingHandler(msg);
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidStreamMessage<T>(T? msg, string? paramName = null)
        {
            if (msg == null)
                ThrowArgumentNull(paramName);
            else if (!(msg is global::Mediator.IStreamMessage))
                ThrowInvalidMessage(msg);
            else
                ThrowMissingHandler(msg);
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidStreamRequest<T>(T? msg, string? paramName = null)
        {
            if (msg == null)
                ThrowArgumentNull(paramName);
            else if (!(msg is global::Mediator.IBaseStreamRequest))
                ThrowInvalidMessage(msg);
            else
                ThrowMissingHandler(msg);
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidStreamCommand<T>(T? msg, string? paramName = null)
        {
            if (msg == null)
                ThrowArgumentNull(paramName);
            else if (!(msg is global::Mediator.IBaseStreamCommand))
                ThrowInvalidMessage(msg);
            else
                ThrowMissingHandler(msg);
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidStreamQuery<T>(T? msg, string? paramName = null)
        {
            if (msg == null)
                ThrowArgumentNull(paramName);
            else if (!(msg is global::Mediator.IBaseStreamQuery))
                ThrowInvalidMessage(msg);
            else
                ThrowMissingHandler(msg);
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowArgumentNull(string? paramName) =>
            throw new global::System.ArgumentNullException(paramName);

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidMessage<T>(T msg) =>
            throw new global::Mediator.InvalidMessageException(msg);

        private static void ThrowIfNull<T>(T? argument, string paramName)
        {
            if (argument == null)
                ThrowArgumentNull(paramName);
        }

        private static void ThrowInvalidNotification<T>(T? argument, string paramName)
        {
            if (argument == null)
                ThrowArgumentNull(paramName);
            else if (!(argument is global::Mediator.INotification))
                ThrowInvalidMessage(argument);
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowAggregateException(global::System.Collections.Generic.List<global::System.Exception> exceptions) =>
            throw new global::System.AggregateException(exceptions);

        private static void MaybeThrowAggregateException(global::System.Collections.Generic.List<global::System.Exception>? exceptions)
        {
            if (exceptions != null)
            {
                ThrowAggregateException(exceptions);
            }
        }
    }
}
